# React.useState
React의 핵심인 상태 관리와 Hooks에 대해 살펴봅니다.

## React의 상태란 무엇인가?
state를 이해하기 위해서는, props를 먼저 살펴 볼 필요가 있습니다. 일반적으로 React에서 모든 데이터의 전달 방향은 부모 컴포넌트에서 자식 컴포넌트로 향하게 되어 있습니다. 따라서 자식 컴포넌트는 필요한 데이터를 부모 컴포넌트로부터 props에 전달 받아 사용이 가능합니다.
하지만 데이터를 수정해야 하거나, 사용자가 입력한 변경된 데이터를 저장해야 하는 경우, props는 읽기 전용이므로 사용할 수 없습니다. 이때 state를 사용할 수 있습니다. 모든 컴포넌트는 state를 가질 수 있으며, state에서는 변경될 수 있는 데이터를 관리할 수 있습니다. state에 저장된 데이터는 사용자-컴포넌트 또는 컴포넌트-컴포넌트 사이에서 상호작용을 하며 값을 바꿀 수 있습니다. 또한 그러한 방식으로 데이터가 변경된 컴포넌트와 자식 컴포넌트들은 리렌더링을 하여 사용자에게 바뀐 상태를 제공할 수 있습니다.
## 상태 변경 시 내부적인 처리 과정은 무엇인가?
컴포넌트의 state에 저장된 데이터가 변경되었을 때, 컴포넌트와 자식 컴포넌트들은 리렌더링을 하여 사용자에게 바뀐 상태를 제공합니다. 데이터로부터 DOM을 조작하는 것은 React가, DOM으로부터 실제 이미지를 만드는 것은 브라우저가 담당합니다.
DOM 자체를 변경하는 과정은 느리기 때문에, React는 Virtual DOM(이하 VDOM), 즉 가상의 DOM을 별도로 정의해서 사용합니다. 이는 브라우저에 실제로 보여지는 DOM이 아니라 메모리에 가상으로 존재하는 DOM으로서 JavaScript 객체입니다. 따라서 작동 성능이 실제로 브라우저에서 DOM을 보여주는 것보다 속도가 훨씬 빠릅니다.
React는 상태가 업데이트되면, 업데이트가 필요한 곳의 UI를 VDOM을 통해 렌더링합니다. 다음으로 VDOM 컴포넌트 트리와 DOM 컴포넌트 트리를 비교하고, 리렌더링 대상 컴포넌트를 지정 후 DOM에 반영합니다. 이렇게 함으로써 시간이 많이 걸리는 DOM 조작 작업과 브라우저의 작업을 줄일 수 있습니다.

## 왜 상태에 직접 값을 할당하지 않고, `setState()`를 사용하는가?
`setState()`를 사용하지 않고 직접 상태를 변경하는 경우, 리렌더링을 발동시키지 않습니다. 반면 `setState()`를 사용하면 변경 불가능한 방식으로, 새로운 상태를 생성하고 이를 상태에 할당합니다. 따라서 React가 상태가 변경되었음을 감지하고 컴포넌트를 리렌더링하게 됩니다.

## React의 Hook이란 무엇이고, 어떤 Hook이 있는가?
Hook은 React 버전 16.8부터 새롭게 추가된 요소로, Hook을 이용하여 기존 Class 바탕의 코드를 작성할 필요 없이 상태 값과 여러 React의 기능을 사용할 수 있도록 설계되었습니다. 앞서 살펴본 `useState()` 외에도 다양한 Hook이 제공됩니다. 대표적인 Hook 몇 가지를 아래에 소개합니다.
### useEffect
`useEffect()`는 렌더러가 부수 효과로 무언가를 수행하게 하고 싶을 때 사용합니다. React 컴포넌트 안에서 데이터를 가져오거나 구독하고, DOM을 직접 조작하는 모든 작업들을 "부수 효과(side effects)"라고 합니다. 다르게 말하면, 부수 효과는 함수가 반환하는 값에 속하지 않는 것들입니다. 이들은 렌더링에 속하지 않지만 렌더링에 의해 영향을 받습니다.
### useMemo
`useMemo()`는 메모화된(memoized) 값을 계산하는 함수를 호출합니다.  메모화된 함수는 함수 호출 결과를 저장하고 캐시합니다. 그 후 함수에 같은 입력이 들어오면 캐시된 값을 반환합니다. React에서 `useMemo()`를 사용하면 캐시된 값과 계산한 값을 비교해서 실제 값이 변경됐는지 검사해 줍니다. `useMemo()`는 우리가 `useMemo()`에 전달한 함수를 사용해 메모화할 값을 계산함으로써 작동합니다. `useMemo()`는 의존 관계가 바뀐 경우에만 이 값을 재계산합니다.
### useCallBack
`useMemo()`와 비슷하지만, `useCallBack()`은 값 대신 함수를 메모화합니다.
### useLayoutEffect
`useLayoutEffect()`는 `useEffect()`와 비슷하지만, 렌더링 사이클에서 렌더링 이후, 브라우저가 변경 내역을 화면에 그리기 전에 호출됩니다. 한편, `useEffect()`는 브라우저의 화면 그리기 이후에 호출됩니다. 
대부분의 경우 `useEffect()`로 원하는 작업을 수행하기에 충분하겠지만, 사용하려는 효과가 브라우저의 화면 그리기에 필수적인 경우에는 `useLayoutEffect()`를 사용하는 것이 적합할 수 있습니다.
### useReducer
리듀서(reducer) 함수는 현재 상태를 받아서 새 상태를 반환하는 함수라고 할 수 있습니다. `useState()`와 비슷하지만, 다수의 하윗값을 포함하는 복잡한 정적 로직을 만드는 경우나 다음 상태가 이전 상태에 의존적인 경우, `useReducer()`가 보다 선호됩니다. 또한 useReducer는 자세한 업데이트를 트리거 하는 컴포넌트의 성능을 최적화할 수 있게 하는데, 이것은 콜백 대신 dispatch를 전달 할 수 있기 때문입니다.